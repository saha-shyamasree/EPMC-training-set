<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName A++V2.4.dtd?><?SourceDTD.Version 2.4?><?ConverterInfo.XSLTName springer2nlmx2.xsl?><?ConverterInfo.Version 2?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">4462005</article-id><article-id pub-id-type="pmid">26063651</article-id><article-id pub-id-type="publisher-id">626</article-id><article-id pub-id-type="doi">10.1186/s12859-015-0626-9</article-id><article-categories><subj-group subj-group-type="heading"><subject>Methodology Article</subject></subj-group></article-categories><title-group><article-title><SecTag type="TITLE"><text><SENT sid="0" pm="."><plain>BitMapper: an efficient all-mapper based on bit-vector computing </plain></SENT>
</text></SecTag></article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Cheng</surname><given-names>Haoyu</given-names></name><address><email>chhy@mail.ustc.edu.cn</email></address><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author"><name><surname>Jiang</surname><given-names>Huaipan</given-names></name><address><email>jhp9650@mail.ustc.edu.cn</email></address><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author"><name><surname>Yang</surname><given-names>Jiaoyun</given-names></name><address><email>jiaoyun@hfut.edu.cn</email></address><xref ref-type="aff" rid="Aff3">3</xref></contrib><contrib contrib-type="author" corresp="yes"><name><surname>Xu</surname><given-names>Yun</given-names></name><address><email>xuyun@ustc.edu.cn</email></address><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author" corresp="yes"><name><surname>Shang</surname><given-names>Yi</given-names></name><address><email>ShangY@missouri.edu</email></address><xref ref-type="aff" rid="Aff4">4</xref></contrib><aff id="Aff1"><label>1</label>Key Laboratory on High Performance Computing, Hefei, Anhui230027, P.R. China </aff><aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000000121679639</institution-id><institution-id institution-id-type="GRID">grid.59053.3a</institution-id><institution>School of Computer Science, </institution><institution>University of Science and Technology of China, </institution></institution-wrap>Hefei, Anhui, 230027 P.R. China </aff><aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="GRID">grid.256896.6</institution-id><institution/><institution>Hefei University of Technology, </institution></institution-wrap>Hefei, 230009 China </aff><aff id="Aff4"><label>4</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2162 3504</institution-id><institution-id institution-id-type="GRID">grid.134936.a</institution-id><institution>Department of Computer Science, </institution><institution>University of Missouri-Columbia, </institution></institution-wrap>Columbia MO, 65203 USA </aff></contrib-group><pub-date pub-type="epub"><day>11</day><month>6</month><year>2015</year></pub-date><pub-date pub-type="collection"><year>2015</year></pub-date><volume>16</volume><elocation-id>192</elocation-id><history><date date-type="received"><day>26</day><month>11</month><year>2014</year></date><date date-type="accepted"><day>22</day><month>5</month><year>2015</year></date></history><permissions><copyright-statement>© Cheng et al. 2015</copyright-statement><license license-type="open-access"><license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly credited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p></license></permissions><abstract id="Abs1"><sec><title><text><SENT sid="1" pm="."><plain>Background </plain></SENT>
</text></title><p><SecTag type="ABS"><text><SENT sid="2" pm="."><plain>As the next-generation sequencing (NGS) technologies producing hundreds of millions of reads every day, a tremendous computational challenge is to map NGS reads to a given reference genome efficiently. </plain></SENT>
<SENT sid="3" pm="."><plain>However, existing methods of all-mappers, which aim at finding all mapping locations of each read, are very time consuming. </plain></SENT>
<SENT sid="4" pm="."><plain>The majority of existing all-mappers consist of 2 main parts, filtration and verification. </plain></SENT>
<SENT sid="5" pm="."><plain>This work significantly reduces verification time, which is the dominant part of the running time. </plain></SENT>
</text></SecTag></p></sec><sec><title><text><SENT sid="6" pm="."><plain>Results </plain></SENT>
</text></title><p><SecTag type="ABS"><text><SENT sid="7" pm="."><plain>An efficient all-mapper, BitMapper, is developed based on a new vectorized bit-vector algorithm, which simultaneously calculates the edit distance of one read to multiple locations in a given reference genome. </plain></SENT>
<SENT sid="8" pm="."><plain>Experimental results on both simulated and real data sets show that BitMapper is from several times to an order of magnitude faster than the current state-of-the-art all-mappers, while achieving higher sensitivity, i.e., better quality solutions. </plain></SENT>
</text></SecTag></p></sec><sec><title><text><SENT sid="9" pm="."><plain>Conclusions </plain></SENT>
</text></title><p><SecTag type="ABS"><text><SENT sid="10" pm="."><plain>We present BitMapper, which is designed to return all mapping locations of raw reads containing indels as well as mismatches. </plain></SENT>
<SENT sid="11" pm="."><plain>BitMapper is implemented in C under a GPL license. </plain></SENT>
<SENT sid="12" pm="."><plain>Binaries are freely available at <ext-link ext-link-type="uri" xlink:href="http://home.ustc.edu.cn/%7Echhy">http://home.ustc.edu.cn/%7Echhy</ext-link>. </plain></SENT>
</text></SecTag></p></sec><sec><title><text><SENT sid="13" pm="."><plain>Electronic supplementary material </plain></SENT>
</text></title><p><SecTag type="ABS"><text><SENT sid="14" pm="."><plain>The online version of this article (doi:10.1186/s12859-015-0626-9) contains supplementary material, which is available to authorized users. </plain></SENT>
</text></SecTag></p></sec></abstract><SecTag type="KEYWORD"><kwd-group xml:lang="en"><title>Keywords</title><kwd>Read alignment</kwd><kwd>Edit distance</kwd><kwd>Multiple locations</kwd><kwd>Simultaneously calculating</kwd><kwd>Bit-vector algorithm</kwd></kwd-group></SecTag><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>© The Author(s) 2015</meta-value></custom-meta></custom-meta-group></article-meta></front><body><SecTag type="INTRO"><sec id="Sec1"><title><text><SENT sid="15" pm="."><plain>Background </plain></SENT>
</text></title><p><text><SENT sid="16" pm="."><plain>Recently, DNA sequencing has become a powerful tool for researches in biology and medicine. </plain></SENT>
<SENT sid="17" pm="."><plain>The decreasing cost and improving speed of the next-generation sequencing (NGS) technologies generate massive reads every day. </plain></SENT>
<SENT sid="18" pm="."><plain>However, a disadvantage of NGS technologies is that they produce sequenced reads of relatively short length. </plain></SENT>
<SENT sid="19" pm="."><plain>For instance, the HiSeq2500 platform of Illumina usually produces 150 bp reads. </plain></SENT>
<SENT sid="20" pm="."><plain>The first step of many genomic researches is finding the mapping locations of these short NGS reads in a given large reference genome. </plain></SENT>
</text></p><p><text><SENT sid="21" pm="."><plain>For this mapping issue, two classes of methods have been developed. </plain></SENT>
<SENT sid="22" pm="."><plain>One class, including Bowtie [1], Bowtie2 [2], BWA [3], GEM [4], etc., is referred to as best-mappers for trying to identify one or a few best mapping locations for each read. </plain></SENT>
<SENT sid="23" pm="."><plain>The other class, including RazerS 3 [5], Hobbes2 [6], and mrFAST [7, 8], is referred to as all-mappers for finding all mapping locations. </plain></SENT>
<SENT sid="24" pm="."><plain>Generally, the selection of different mappers depends on the needs of down-stream applications. </plain></SENT>
<SENT sid="25" pm="."><plain>Finding one or a few best mapping locations for each read using best-mappers is enough in most cases (e.g., mapping DNA-protein interactions, whole-transcriptome sequencing and whole genome expression profiling). </plain></SENT>
<SENT sid="26" pm="."><plain>However, for some specific applications, such as ChIP-seq experiments, CNVs (copy number variation) calling and detecting structural variants, it is necessary to identify all mapping locations using all-mappers. </plain></SENT>
</text></p><p><text><SENT sid="27" pm="."><plain>Due to the different purposes, identifying all mapping locations using all-mappers is usually much slower than finding one or a few best locations using best-mappers. </plain></SENT>
<SENT sid="28" pm="."><plain>An important reason is that all-mappers have to enumerate all possible locations, while best-mappers can use some heuristic methods to select the most likely one. </plain></SENT>
<SENT sid="29" pm="."><plain>There are a lot of matches for some reads due to huge numbers of segmental duplications and common repeats in reference genomes. </plain></SENT>
<SENT sid="30" pm="."><plain>Thus, finding all mapping locations is still a computationally very expensive problem. </plain></SENT>
</text></p><p><text><SENT sid="31" pm="."><plain>To solve this problem, many all-mappers have been developed. </plain></SENT>
<SENT sid="32" pm="."><plain>Most of them consist of two parts, filtration and verification. </plain></SENT>
<SENT sid="33" pm="."><plain>Filtration reduces the number of the locations that need to be verified (called candidates), especially when a reference genome is extremely large. </plain></SENT>
<SENT sid="34" pm="."><plain>For example, Hobbes [9] uses a dynamic programming algorithm to select several q-grams with the lowest frequency, where q-grams are the subsequences with length of q. </plain></SENT>
<SENT sid="35" pm="."><plain>Therefore, the number of candidates is minimal. </plain></SENT>
<SENT sid="36" pm="."><plain>Another filter proposed by Hobbes 2 chooses k+2 q−grams instead of k+1 and only verifies the locations that appear at least two times. </plain></SENT>
<SENT sid="37" pm="."><plain>Recently, Masai [10] improved the performance of filtration by generating candidate locations of multiple reads simultaneously and using approximate seeds. </plain></SENT>
<SENT sid="38" pm="."><plain>Compared with filtration, verification used for edit distance is the dominant part of the whole running time in current mappers [8]. </plain></SENT>
<SENT sid="39" pm="."><plain>Several algorithms have been proposed to speedup verification. </plain></SENT>
<SENT sid="40" pm="."><plain>A bit-vector algorithm proposed by Myers [11] uses bit representation contained in a machine word to calculte edit distance. </plain></SENT>
<SENT sid="41" pm="."><plain>RazerS 3 [5] implements a banded version of Myers’ algorithm [12], which only calculates several consecutive diagonals rather than the whole dynamic programming matrix. </plain></SENT>
<SENT sid="42" pm="."><plain>Although the current banded method of verification is quite quick, it only calculates the edit distance of a read to one location rather than multiple locations. </plain></SENT>
</text></p><p><text><SENT sid="43" pm="."><plain>In this paper, we present BitMapper, an efficient read mapper which is designed to return all mapping locations of raw reads containing indels as well as mismatches. </plain></SENT>
<SENT sid="44" pm="."><plain>It includes a new vectorized bit-vector algorithm using a single machine word to represent several bit vectors and simultaneously calculates the edit distance of a read to multiple locations in a given reference genome. </plain></SENT>
<SENT sid="45" pm="."><plain>A vectorized verification scheme is also proposed to work with the new bit-vector algorithm. </plain></SENT>
<SENT sid="46" pm="."><plain>Experimental results show that the running time of BitMapper is from several times to an order of magnitude faster than the best existing all-mappers, including Hobbes 2, RazerS 3, mrFAST (with FastHASH) [8], Masai and Yara [13]. </plain></SENT>
</text></p></sec></SecTag><SecTag type="METHODS"><sec id="Sec2"><title><text><SENT sid="47" pm="."><plain>Methods </plain></SENT>
</text></title><p><text><SENT sid="48" pm="."><plain>First, we define the read mapping problem and related concepts. </plain></SENT>
</text></p><sec id="d30e377"><title><text><SENT sid="49" pm="."><plain>Definition1. </plain></SENT>
</text></title><p><text><SENT sid="50" pm="."><plain>Given a set of reads R and a reference genome S, find all locations in S where the hamming or edit distance of each read in R is at most k. </plain></SENT>
</text></p><p><text><SENT sid="51" pm="."><plain>Hamming and edit distance are two common distance metrics for sequence alignment. </plain></SENT>
<SENT sid="52" pm="."><plain>Hamming distance only includes the substitutions of the corresponding symbols between two strings of equal length, while edit distance consists of substitutions, insertions and deletions. </plain></SENT>
<SENT sid="53" pm="."><plain>Calculating hamming distance is relatively easy and has been well solved. </plain></SENT>
<SENT sid="54" pm="."><plain>On the other hand, calculating edit distance efficiently is still difficult, which is the focus on this article. </plain></SENT>
</text></p><p><text><SENT sid="55" pm="."><plain>Similar to existing short reads mappers, BitMapper mainly consists of two parts: filtration and verification. </plain></SENT>
<SENT sid="56" pm="."><plain>In the following, we first briefly describe the procedure of existing approaches and then present and analyze BitMapper in detail. </plain></SENT>
</text></p></sec><sec id="Sec3"><title><text><SENT sid="57" pm="."><plain>Filtration </plain></SENT>
</text></title><p><text><SENT sid="58" pm="."><plain>Filtration is an important phase for sequence alignment, especially if a reference genome is extremely large. </plain></SENT>
<SENT sid="59" pm="."><plain>Only the regions consisting of potential mapping locations can be reserved after filtration. </plain></SENT>
<SENT sid="60" pm="."><plain>Currently, the basic principle of nearly all q-gram-based filtration strategies is that the number of q-grams shared between two sequences should exceed a certain threshold if they are potentially similar. </plain></SENT>
<SENT sid="61" pm="."><plain>Next, we briefly summarize commonly usedq-gram-based approaches. </plain></SENT>
</text></p><sec id="Sec4"><title><text><SENT sid="62" pm="."><plain>Pigeonhole principle </plain></SENT>
</text></title><p><text><SENT sid="63" pm="."><plain>A simple and efficient filtration strategy is pigeonhole principle: if l items are put into l+1 boxes, then one or more boxes would be empty. </plain></SENT>
<SENT sid="64" pm="."><plain>In its application on sequence alignment, first each read is divided into k+1 non-overlapping q-grams, where k is the threshold of edit distance or hamming distance. </plain></SENT>
<SENT sid="65" pm="."><plain>If the distance between a read and a candidate region is less than k, at least one in k+1 non-overlapping q-grams of the read can be mapped to the reference exactly, since a substitution, insertion or deletion only affects a q-gram. </plain></SENT>
<SENT sid="66" pm="."><plain>A more general version of pigeonhole principle is that if a read is able to be cut into k+m non-overlapping q-grams, sharing at least m of them with a read is necessary for each mappinglocation. </plain></SENT>
</text></p></sec><sec id="Sec5"><title><text><SENT sid="67" pm="."><plain>Count filtering </plain></SENT>
</text></title><p><text><SENT sid="68" pm="."><plain>Compared with pigeonhole principle, a more involved filtration strategy is count filtering. </plain></SENT>
<SENT sid="69" pm="."><plain>Given a sequence s, there are |s|−q+1 overlapping q-grams that are obtained by sliding a window of length q over s, where |s| is the length of s. </plain></SENT>
<SENT sid="70" pm="."><plain>As in the explanation of pigeonhole principle, a substitution only affects at most q overlapping q-grams. </plain></SENT>
<SENT sid="71" pm="."><plain>Thus, no more than k×q q-grams could be affected with hamming distance k. </plain></SENT>
<SENT sid="72" pm="."><plain>If the hamming distance between s and another sequence r is less than k, then the number T of shared q-grams is at least. (1)\documentclass[12pt]{minimal} \usepackage{amsmath} \usepackage{wasysym} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage{mathrsfs} \usepackage{upgreek} \setlength{\oddsidemargin}{-69pt} \begin{document} $$ T=|s|-(k+1)\times q+1 $$ \end{document}T=|s|−(k+1)×q+1 </plain></SENT>
</text></p><p><text><SENT sid="73" pm="."><plain>The lower bound T of edit distance is similar to that of hamming distance. </plain></SENT>
<SENT sid="74" pm="."><plain>The first method of count filtering on sequence alignment is a modified SWIFT algorithm [14] used in RazerS [15]. </plain></SENT>
</text></p></sec><sec id="Sec6"><title><text><SENT sid="75" pm="."><plain>Our implementation </plain></SENT>
</text></title><p><text><SENT sid="76" pm="."><plain>Pigeonhole principle is faster than count filtering on filtration phase, while the verification time of the pigeonhole-principle-based mappers is more than that of the count-filtering-based mappers. </plain></SENT>
<SENT sid="77" pm="."><plain>In fact, there is a tradeoff between filtration and verification. </plain></SENT>
<SENT sid="78" pm="."><plain>Because the proportion of verification time for the pigeonhole-principle-based mappers is larger than that for the count-filtering-based mappers, the former benefit more from the improvement of verification than the latter. </plain></SENT>
<SENT sid="79" pm="."><plain>As our verification method is efficient, Bitmapper used pigeonhole principle instead of count filtering. </plain></SENT>
</text></p></sec></sec><sec id="Sec7"><title><text><SENT sid="80" pm="."><plain>Verification </plain></SENT>
</text></title><p><text><SENT sid="81" pm="."><plain>The locations reserved after filtration are the candidates for matches. </plain></SENT>
<SENT sid="82" pm="."><plain>During the verification phase, these candidates should be verified by calculating their edit distance or hamming distance to each read. </plain></SENT>
<SENT sid="83" pm="."><plain>Compared with computing hamming distance, computing edit distance is extremely time-consuming. </plain></SENT>
<SENT sid="84" pm="."><plain>In the following, we first describe the theoretical basis for our vectorized Gene Myers’ bit-vector algorithm, and illustrate the algorithm in detail. </plain></SENT>
<SENT sid="85" pm="."><plain>Then, we present a vectorized verification scheme, which is designed to work with the vectorized Gene Myers’ bit-vector algorithm. </plain></SENT>
</text></p><sec id="Sec8"><title><text><SENT sid="86" pm="."><plain>Theoretical basis </plain></SENT>
</text></title><p><text><SENT sid="87" pm="."><plain>For sequence alignment, the reads and the reference genomes can be viewed as the strings including letters A, C, G, T and N. </plain></SENT>
<SENT sid="88" pm="."><plain>Assume the length of read r is m, the length of genome s is n, and the threshold of edit distance is k. </plain></SENT>
<SENT sid="89" pm="."><plain>The dynamic programming algorithm proposed in [16] is a classic method for this problem, which computes a dynamic programming matrix C[0…m,0…n] of size (m+1)×(n+1). </plain></SENT>
<SENT sid="90" pm="."><plain>The well-known recurrence formula is as follows. (2)\documentclass[12pt]{minimal} \usepackage{amsmath} \usepackage{wasysym} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage{mathrsfs} \usepackage{upgreek} \setlength{\oddsidemargin}{-69pt} \begin{document} $$ {\small{\begin{aligned} &amp;E[i,j]=\left\{ \begin{array}{ll} 0&amp; r_{i}=s_{j}\\ 1&amp; {r_{i}\neq s_{j}}\\ \end{array} \right.&amp; {i \in [1,m],j \in [1,n]} &amp; \\ &amp;C[i,j]=min\left\{ \begin{array}{ll} C[i,j-1]+1\\ C[i-1,j]+1\\ C[i-1,j-1]+E[i,j] \end{array} \right.&amp; {i \in [1,m],j \in [1,n]}&amp; \\ &amp;C[0,j]=0,C[i,0]=i &amp; {i \in [0,m],j \in [0,n]}&amp; \end{aligned}}} $$ \end{document}E[i,j]=0ri=sj1ri≠sji∈[1,m],j∈[1,n]C[i,j]=minC[i,j−1]+1C[i−1,j]+1C[i−1,j−1]+E[i,j]i∈[1,m],j∈[1,n]C[0,j]=0,C[i,0]=ii∈[0,m],j∈[0,n] </plain></SENT>
</text></p><p><text><SENT sid="91" pm="."><plain>Its time complexity is O(m×n) and it is very slow when a reference genome is large. </plain></SENT>
<SENT sid="92" pm="."><plain>Actually, calculating the whole dynamic programming matrix is unnecessary when the edit distance threshold k has been set in advance. </plain></SENT>
<SENT sid="93" pm="."><plain>As stated in the following Lemma 1, the size of computing area in dynamic programming matrix is related to k, which has been proven in [17]. </plain></SENT>
</text></p><sec id="d30e962"><title><text><SENT sid="94" pm="."><plain>Lemma1. </plain></SENT>
</text></title><p><text><SENT sid="95" pm="."><plain>Given a read of length m, a candidate location d in a reference genome and an edit distance threshold k, the start and end positions of potential matches may be from d−k to d+k and from d+m−k−1 to d+m+k−1, respectively. </plain></SENT>
<SENT sid="96" pm="."><plain>In other words, the length of the verification window, which would be calculated with the read, is m+2k. </plain></SENT>
</text></p><p><text><SENT sid="97" pm="."><plain>Figure 1 shows an example for Lemma 1. </plain></SENT>
<SENT sid="98" pm="."><plain>Note that the candidate location d is obtained by subtracting the offset c from dq, where dq is an exactly matched location of a q-gram and c is the offset of this q-gram in the read. </plain></SENT>
<SENT sid="99" pm="."><plain>If there are only at most k deletions, the segment starting at d−k and ending at d+m+k−1 needs to be computed. </plain></SENT>
<SENT sid="100" pm="."><plain>If there are only at most k insertions, the segment range needing to be considered is from d+k to d+m−k−1. </plain></SENT>
<SENT sid="101" pm="."><plain>Combining with these two intervals, the range of maximal verification window is from d-k to d+m+k−1.Fig. 1The verification window in reference genome. </plain></SENT>
<SENT sid="102" pm="."><plain>It includes the candidate mapping locations of the read with edit distance up to 3 </plain></SENT>
</text></p><p><text><SENT sid="103" pm="."><plain>According to Lemma 1, the length of verification window is m+2k. </plain></SENT>
<SENT sid="104" pm="."><plain>Thus, only (m+2k+1)×(m+1) cells in dynamic programming matrix need to be calculated. </plain></SENT>
<SENT sid="105" pm="."><plain>We define the diagonal which is shifted from the main diagonal by k diagonals to the right as “base diagonal”. </plain></SENT>
<SENT sid="106" pm="."><plain>It corresponds to the situation that only substitutions are considered, since the computing path moves right down from the current cell in dynamic programming matrix to the adjacent cell when a substitution occurs. </plain></SENT>
<SENT sid="107" pm="."><plain>For a deletion in the reference genome, the computing path goes right to the adjacent cell. </plain></SENT>
<SENT sid="108" pm="."><plain>For an insertion, this path goes down to the adjacent cell. </plain></SENT>
<SENT sid="109" pm="."><plain>Thus, the rightmost and the leftmost diagonals are obtained by sliding k diagonals from the “base diagonal” to its right and left, respectively. </plain></SENT>
<SENT sid="110" pm="."><plain>In fact, the computing area in dynamic programming matrix is a banded parallelogram, as shownin Fig. 2.Fig. 2The computing area in dynamic programming matrix with the edit distance threshold k = 2. </plain></SENT>
<SENT sid="111" pm="."><plain>The initial cells should be set to 0 because the start locations of potential matches can not be known in advance </plain></SENT>
</text></p><p><text><SENT sid="112" pm="."><plain>An efficient solution for this problem is the bit-vector algorithm proposed in [11], which is based on the observation that the difference of the values between adjacent cells in dynamic programming matrix is at most 1. </plain></SENT>
<SENT sid="113" pm="."><plain>It is able to encode a whole column in dynamic programming matrix using bit vectors and compute a column by bit operations rather than cell-by-cell. </plain></SENT>
<SENT sid="114" pm="."><plain>Banded versions of Myers’ bit-vector algorithm have been implemented in [5] and [12]. </plain></SENT>
<SENT sid="115" pm="."><plain>They encode a banded parallelogram in dynamic programming matrix into columns for column-wise computation, since only limited consecutive diagonals need to be calculated rather than the whole dynamic programming matrix, according to the analysis above. </plain></SENT>
<SENT sid="116" pm="."><plain>Figure 2 shows that at most 2k+1 cells in each column need to be calculated, so that the length of the bit vectors is also 2k+1. </plain></SENT>
<SENT sid="117" pm="."><plain>If 2k+1 is less than the word size of computer, a column could be processed in one step. </plain></SENT>
</text></p></sec></sec><sec id="Sec9"><title><text><SENT sid="118" pm="."><plain>Vectorized Gene Myers’ bit-vector algorithm </plain></SENT>
</text></title><p><text><SENT sid="119" pm="."><plain>A significant characteristic of the NGS reads is that the length of them is relatively short. </plain></SENT>
<SENT sid="120" pm="."><plain>For the down-stream applications using all-mappers, the edit distance threshold is usually set to 4 % or 5 % of the read length. </plain></SENT>
<SENT sid="121" pm="."><plain>Thus, the edit distance threshold k is usually low. </plain></SENT>
<SENT sid="122" pm="."><plain>It means that a few bits are enough for banded bit-vector algorithms to calculate edit distance. </plain></SENT>
<SENT sid="123" pm="."><plain>For example, the length of the reads sequenced by Illumina platform is always under 150 so that the threshold k is set to 7. </plain></SENT>
<SENT sid="124" pm="."><plain>If k=7, the length of bit vectors is 15, while the word size of modern computers is typically 64 and the Streaming SIMD Extensions (SSE) instruction set has several 128-bit registers. </plain></SENT>
<SENT sid="125" pm="."><plain>Therefore, it is possible to load multiple bit vectors into a machine word or a 128-bit SSE register. </plain></SENT>
<SENT sid="126" pm="."><plain>Furthermore, the problem can be converted to how to compute the edit distance between several patterns and a text. </plain></SENT>
<SENT sid="127" pm="."><plain>Based on these observations, we propose a new vectorized Gene Myers’ bit-vector algorithm to simultaneously process a text with multiple patterns. </plain></SENT>
</text></p><p><text><SENT sid="128" pm="."><plain>First we briefly introduce the current bit-vector algorithm proposed in [12], which is the basis of our vectorized algorithm. </plain></SENT>
<SENT sid="129" pm="."><plain>It uses delta encoding in dynamic programming matrix C[0…m,0…n]. </plain></SENT>
<SENT sid="130" pm="."><plain>Specifically, for column j, the bit delta vectors are. (3)\documentclass[12pt]{minimal} \usepackage{amsmath} \usepackage{wasysym} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage{mathrsfs} \usepackage{upgreek} \setlength{\oddsidemargin}{-69pt} \begin{document} $$\begin{array}{*{20}l} &amp;{HP}_{j}[i] \equiv(C[i,j]-C[i,j-1]=+1)&amp; \\ &amp;{HN}_{j}[i] \equiv(C[i,j]-C[i,j-1]=-1)&amp; \\ &amp;{VP}_{j}[i] \equiv(C[i,j]-C[i-1,j]=+1)&amp; i \in [1,m],j \in [1,n] &amp; \\ &amp;{VN}_{j}[i] \equiv(C[i,j]-C[i-1,j]=-1)&amp;\\ &amp;D0_{j}[i]=C[i,j]-C[i-1,j-1]&amp; \\ &amp;{Peq}_{j}[s][i]\equiv(pattern[i]=s)&amp; s \in \{A,T,G,C\}&amp; \end{array} $$ \end{document}HPj[i]≡(C[i,j]−C[i,j−1]=+1)HNj[i]≡(C[i,j]−C[i,j−1]=−1)VPj[i]≡(C[i,j]−C[i−1,j]=+1)i∈[1,m],j∈[1,n]VNj[i]≡(C[i,j]−C[i−1,j]=−1)D0j[i]=C[i,j]−C[i−1,j−1]Peqj[s][i]≡(pattern[i]=s)s∈{A,T,G,C} </plain></SENT>
</text></p><p><text><SENT sid="131" pm="."><plain>where H P j,H N j,V P j,V N j,D0j and P e q j are the jth element of H P,H N,V P,V N,D and P e q, respectively. </plain></SENT>
<SENT sid="132" pm="."><plain>And the notation H P j[i],H N j[i],V P j[i],V N j[i],D0j[i] and P e q j[s][i] denote the ith bit of H P j,H N j,V P j,V N j,D0j and P e q j[s], respectively. </plain></SENT>
</text></p><p><text><SENT sid="133" pm="."><plain>If the values of these bit vectors in column j−1 have already been known, then the bit vectors in column j can be computed as following. </plain></SENT>
</text></p><p><text><SENT sid="134" pm="."><plain> </plain></SENT>
</text></p><p><text><SENT sid="135" pm="."><plain>where t[p] is the pth element of text. </plain></SENT>
<SENT sid="136" pm="."><plain>Because the length of each column in computing area is 2k+1, so the length of these bit vectors is also 2k+1. </plain></SENT>
</text></p><p><text><SENT sid="137" pm="."><plain>Based on the Algorithm 1, we developed the vectorized Gene Myers’ bit-vector algorithm. </plain></SENT>
<SENT sid="138" pm="."><plain>Briefly, it packs multiple bit-vectors of different patterns into a machine word so that these patterns are able to be processed with one text simultaneously. </plain></SENT>
<SENT sid="139" pm="."><plain>The calculating of each bit-vector is similar to the previous banded bit-vector algorithm [12]. </plain></SENT>
<SENT sid="140" pm="."><plain>However, some problems would occur when multiple bit-vectors are processed as a whole. </plain></SENT>
<SENT sid="141" pm="."><plain>From Algorithm 1, only six operations have been used: ‘ ⊕’, ‘ |’, ‘ &amp;’, ‘ ≫’, ‘ ∼’ and ‘+’. </plain></SENT>
<SENT sid="142" pm="."><plain>They can be divided into two groups. </plain></SENT>
<SENT sid="143" pm="."><plain>The first group consists of ‘ ⊕’, ‘ |’, ‘ &amp;’ and ‘ ∼’, while ‘ ≫’ and ‘+’ belong to the second group. </plain></SENT>
<SENT sid="144" pm="."><plain>Using the operations of the first group in a machine word including multiple bit vectors does not have any difficulty, because the bit vectors in it cannot be affected with each other. </plain></SENT>
<SENT sid="145" pm="."><plain>However, implementing the operations of the second group as a whole would influence each other. </plain></SENT>
<SENT sid="146" pm="."><plain>For operation ‘+’, the carries resulted from addition of lower bit vectors would affect the nearly upper bit vectors. </plain></SENT>
<SENT sid="147" pm="."><plain>For operation ‘ ≫’, the lowest bit in upper bit vector would move right to influence the nearly lower bit vector. </plain></SENT>
</text></p><p><text><SENT sid="148" pm="."><plain>To solve the problem about operation ‘+’, the data structures of the variables used in our vectorized Gene Myers’ bit-vector algorithm have been redesigned. </plain></SENT>
<SENT sid="149" pm="."><plain>For the previous banded bit-vector algorithm [12], 2k+1 bits are enough for each variable. </plain></SENT>
<SENT sid="150" pm="."><plain>Intuitively, for the vectorized algorithm, the length of each variable, which represents n bit vectors, is (2k+1)×n. </plain></SENT>
<SENT sid="151" pm="."><plain>However, if multiple bit vectors are loaded into a machine word as this, the problem above could not be solved. </plain></SENT>
<SENT sid="152" pm="."><plain>Our solution is to use one more bit between two bit vectors as a buffer, so that the carries resulted from the operation ‘+’ among the lower bit vectors would not affect the upper bit vectors. </plain></SENT>
<SENT sid="153" pm="."><plain>For example, V P l, which represents the difference of values between the vertical cells for pattern l, is a part of V P, starting from (2k+2)×lth bit and ending at (2k+2)×(l+1)−1th bit. </plain></SENT>
<SENT sid="154" pm="."><plain>For h patterns, the bit vectors of them are assembled together so that the length of variables including VP, V N,H P,H N,D0 and Peq is not less than (2k+2)×h, as shown in Fig. 3. </plain></SENT>
<SENT sid="155" pm="."><plain>And the problem about operation ‘ ≫’ has been solved in our vectorized Gene Myers’ bit-vector algorithm by using an extra ‘ &amp;’ operation with a predefined bitmask.Fig. 3The data structure for the variables containing several bit vectors. </plain></SENT>
<SENT sid="156" pm="."><plain>Each pattern needs (2k+2) bits to represent itself </plain></SENT>
</text></p><p><text><SENT sid="157" pm="."><plain>Our vectorized Gene Myers’ bit-vector algorithm proceeds column-by-column through the dynamic programming matrix. </plain></SENT>
<SENT sid="158" pm="."><plain>If the length of patterns is less than that of the text, it returns the optimal end location for each pattern on text. </plain></SENT>
<SENT sid="159" pm="."><plain>Otherwise, it returns the optimal end locations for the text on each pattern. </plain></SENT>
<SENT sid="160" pm="."><plain>As an example, we present the outline of the algorithm for the second situation as follows. Preprocess the variables for column 0. Set the Peq array for the first 2k+1 symbols in each pattern.Set VP, VN and E to 0, where E contains the edit distances for h patterns. Scan and compute the banded parallelogram in the dynamic programming matrix from left to right by column. Compute HP, HN and D0 of column j from VP and VN of column j-1.Compute VP and VN of next column using HP, HN and D0.Set Peq for next column by shifting to the right of the current Peq.Update E for this column using D0. Output the locations with the lowest edit distance as the optimal end location on each pattern, separately. </plain></SENT>
<SENT sid="161" pm="."><plain>The range in E from (2k+2)×jth bit to (2k+2)×(j+1)−1th bit denotes the edit distance of pattern j. </plain></SENT>
</text></p><p><text><SENT sid="162" pm="."><plain>All of the patterns have to be processed one by one in step 3, while step 1 and step 2 can process multiple patterns simultaneously. </plain></SENT>
<SENT sid="163" pm="."><plain>Fortunately, unlike step 1 and step 2, step 3 is not always necessary due to two reasons: a) the number of matched locations is much less than that of the candidate locations, and b) a simple branch-cut strategy is used in step 2 to stop algorithm earlier, as described in [5]. </plain></SENT>
<SENT sid="164" pm="."><plain>More details of the vectorized Gene Myers’ bit-vector algorithm can be found in the Additional file 1: Section S5. </plain></SENT>
</text></p></sec><sec id="Sec10"><title><text><SENT sid="165" pm="."><plain>Influence of the number of patterns </plain></SENT>
</text></title><p><text><SENT sid="166" pm="."><plain>We have already implemented the vectorized Gene Myers’ bit-vector algorithm using 64-bit machine word and 128-bit SSE2 register. </plain></SENT>
<SENT sid="167" pm="."><plain>It can calculate the edit distance of a text with n patterns. </plain></SENT>
<SENT sid="168" pm="."><plain>In order to figure out the influence of different n, we selected a 100 bp read from specimen HG00096 as a text and regarded 1 thousand subsequences of human genome starting at the candidate locations of this read as patterns. </plain></SENT>
<SENT sid="169" pm="."><plain>The threshold k of edit distance was set to 4. </plain></SENT>
<SENT sid="170" pm="."><plain>Because the length of each bit vector is 2k + 2=10 and the length of a SSE register is 128, the vectorized Gene Myers’ bit-vector algorithm can process at most 12 patterns with a text simultaneously. </plain></SENT>
<SENT sid="171" pm="."><plain>Figure 4 shows the running time of the algorithm with different n. </plain></SENT>
<SENT sid="172" pm="."><plain>Although the performance was improved until n=12, we found that the running time decreased rapidly from n=1 to n=8, while it only decreased a little from n=9 to n=12.Fig. 4Performance for the vectorized Gene Myers’ bit-vector algorithm according to different n  </plain></SENT>
</text></p><p><text><SENT sid="173" pm="."><plain>The reason is that for the original banded bit-vector algorithm which calculates the edit distance between a text and a pattern, algorithm stops once it meets the requirement of the branch-cut strategy. </plain></SENT>
<SENT sid="174" pm="."><plain>For our vectorized Gene Myers’ bit-vector algorithm, calculating stops until all of the patterns meet the requirement. </plain></SENT>
<SENT sid="175" pm="."><plain>It is difficult when n is large and would result in extra cost. </plain></SENT>
<SENT sid="176" pm="."><plain>Therefore, we set n to 8 in most cases. </plain></SENT>
<SENT sid="177" pm="."><plain>For higher edit distance threshold, n is set to 4 since a 128-bit register cannot load 8 bit vectors. </plain></SENT>
</text></p></sec><sec id="Sec11"><title><text><SENT sid="178" pm="."><plain>Vectorized verification scheme </plain></SENT>
</text></title><p><text><SENT sid="179" pm="."><plain>In order to make full use of the vectorized algorithm, the patterns used to compare with a same text should be collected. </plain></SENT>
<SENT sid="180" pm="."><plain>The traditional verification scheme, which only selects a read and a subsequence in given reference genome as input every time, is not suitable for our vectorized Gene Myers’ bit-vector algorithm. </plain></SENT>
<SENT sid="181" pm="."><plain>It is necessary to propose a vectorized verification scheme that considers multiple reads as patterns and a subsequences in given reference genome as text, or vice versa. </plain></SENT>
<SENT sid="182" pm="."><plain>In other words, multiple reads may correspond to one location in given reference genome, or multiple locations correspond to one read. </plain></SENT>
</text></p><p><text><SENT sid="183" pm="."><plain>Figure 5a shows the vectorized verification scheme A, which considers multiple reads as patterns and a subsequence in given reference genome as a text. </plain></SENT>
<SENT sid="184" pm="."><plain>All of the four reads have a matched 3-gram ATG in the reference genome and share the same candidate location d. </plain></SENT>
<SENT sid="185" pm="."><plain>Generally, this scheme needs to build a reads index in order to collect the reads sharing the same locations efficiently. </plain></SENT>
<SENT sid="186" pm="."><plain>Figure 5b shows vectorized verification scheme B that considers a read as a text and multiple subsequences starting at the candidate locations of the read as patterns. </plain></SENT>
<SENT sid="187" pm="."><plain>The read here corresponds to two subsequences sharing a 2-gram AT. </plain></SENT>
<SENT sid="188" pm="."><plain>These two subsequences are obtained by looking up the index of the reference genome using the non-overlapping q-grams of the read.Fig. 5Two vectorized verification schemes for the vectorized Gene Myers’ bit-vector algorithm. a A location in a reference genome corresponds to four reads. b A read corresponds to two locations in the reference genome </plain></SENT>
</text></p><p><text><SENT sid="189" pm="."><plain>According to the analysis above, we found that scheme A takes advantage of the repeatability of the reads, while B takes advantage of the repeatability of the reference genomes. </plain></SENT>
<SENT sid="190" pm="."><plain>In the experimental results presented in Additional file 1: Section S2, the repeatability of genomes is much more than that of reads. </plain></SENT>
<SENT sid="191" pm="."><plain>Therefore, scheme B suits the vectorized Gene Myers’ bit-vector algorithm better than A. </plain></SENT>
<SENT sid="192" pm="."><plain>Another advantage of scheme B is that it does not need an extra index of reads. </plain></SENT>
<SENT sid="193" pm="."><plain>For the reasons outlined above, BitMapper is implemented as scheme B. </plain></SENT>
</text></p></sec></sec></sec></SecTag><SecTag type="RESULTS,DISCUSS"><sec id="Sec12"><title><text><SENT sid="194" pm="."><plain>Results and discussion </plain></SENT>
</text></title><p><text><SENT sid="195" pm="."><plain>BitMapper was compared with five state-of-the-art all-mappers, including mrFAST (with FastHASH), Hobbes 2, RazerS 3, Masai and Yara, and three popular best-mappers, Bowtie 2, GEM and BWA in our experiments. </plain></SENT>
<SENT sid="196" pm="."><plain>The default configurations of these mappers were used except stated otherwise, and the results were output in the SAM format. </plain></SENT>
<SENT sid="197" pm="."><plain>For a fair comparison, all mappers ran on the same computer with an Intel(R) Core(TM) i7-4770 processor and 24GB of RAM running 64-bit Ubuntu 14.04. </plain></SENT>
</text></p><p><text><SENT sid="198" pm="."><plain>The distance metric used in our experiments was edit distance with threshold 5 %. </plain></SENT>
<SENT sid="199" pm="."><plain>The reference genomes were the whole genome of human (NCBI HG19), caenorhabditis elegans (WormBase WS201) and arabidopsis thaliana (assembly TAIR10). </plain></SENT>
<SENT sid="200" pm="."><plain>In the following, mapping time and sensitivity on both real and simulated data sets were presented. </plain></SENT>
</text></p><sec id="Sec13"><title><text><SENT sid="201" pm="."><plain>Sensitivity comparison using Rabema results </plain></SENT>
</text></title><p><text><SENT sid="202" pm="."><plain>In this experiment, 100 k simulated 100 bp reads of human were generated by a simulator tool Mason [18] using default profile setting. </plain></SENT>
<SENT sid="203" pm="."><plain>And we also selected a real data set consisting of 1 million 100 bp reads from specimen HG00096 of the 1000 Genome project [19]. </plain></SENT>
<SENT sid="204" pm="."><plain>To compare the sensitivity of single-end alignment in different genomes, we used the first 1 million 100 bp reads of the data sets SRX026594 and the first 1 million 101 bp reads of SRR1604937, which were obtained from the DNA Data Bank of Japan (DDBJ) repository [20] and National Center for Biotechnology Information (NCBI) repository [21], respectively. </plain></SENT>
</text></p><p><text><SENT sid="205" pm="."><plain>To compare the sensitivity of different mappers fairly, Rabema benchmark [22] was used to evaluate them. </plain></SENT>
<SENT sid="206" pm="."><plain>It has been widely used in recent articles, such as [5, 6] and [10]. </plain></SENT>
<SENT sid="207" pm="."><plain>The categories of sensitivity scores provided by Rabema benchmark include all, all-best, and any-best, which are designed to denote the mapped fraction of all, all of the best, and any of the best matches. </plain></SENT>
<SENT sid="208" pm="."><plain>And to measure these scores, Rabema benchmark defines two metrics: normalized found interval and found interval. </plain></SENT>
<SENT sid="209" pm="."><plain>For normalized found interval, each read is given at most one point no matter how many mapping locations it has. </plain></SENT>
<SENT sid="210" pm="."><plain>For found interval, each mapping location is given one point [see Additional file 1: Section S4 for more detailed illustration]. </plain></SENT>
<SENT sid="211" pm="."><plain>Note that we only presented the Rabema scores (normalized found interval) in the following, and presented the Rabema scores (found interval) in Additional file 1: Section S4 due to the limited space. </plain></SENT>
<SENT sid="212" pm="."><plain>Because Rabema benchmark needs a baseline of mapping locations to build a gold standard, we implemented RazerS 3 in full sensitivity mode, which can report 100 % of mapping locations for each read. </plain></SENT>
</text></p><sec id="Sec14"><title><text><SENT sid="213" pm="."><plain>Rabema benchmark results on simulated data </plain></SENT>
</text></title><p><text><SENT sid="214" pm="."><plain>Table 1 shows the results of mapping 100k simulated reads to the reference genome of human. </plain></SENT>
<SENT sid="215" pm="."><plain>The Rabema all, all-best and any-best scores were presented here. </plain></SENT>
<SENT sid="216" pm="."><plain>Each Rabema category has a large number and 6 small numbers representing the total score and the scores for mapping locations with \documentclass[12pt]{minimal} \usepackage{amsmath} \usepackage{wasysym} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage{mathrsfs} \usepackage{upgreek} \setlength{\oddsidemargin}{-69pt} \begin{document} $\binom {0\ 1\ 2}{3\ 4\ 5}$ \end{document}012345 errors, respectively. </plain></SENT>
<SENT sid="217" pm="."><plain>Best-mappers including Bowtie 2, GEM and BWA were implemented in both high and default sensitivity mode. </plain></SENT>
<SENT sid="218" pm="."><plain>In high sensitivity mode, the Rabema all-scores (normalized found interval) for Bowtie 2, BWA and GEM were 99.73 %, 97.80 % and 96.02 %, respectively. </plain></SENT>
<SENT sid="219" pm="."><plain>It seems that these best-mappers can achieve nearly full sensitivity. </plain></SENT>
<SENT sid="220" pm="."><plain>However, the Rabema all-scores (found interval) of BWA and GEM, which can be found in in Additional file 1: Table S3, were 86.67 % and 61.46 %, respectively. </plain></SENT>
<SENT sid="221" pm="."><plain>For Bowtie 2, although the Rabema all-scores (found interval) was still more than 98 %, it was extremely slow using one thread. </plain></SENT>
<SENT sid="222" pm="."><plain>Thus, we implemented Bowtie 2 with 16 threads and did not present its running time here. </plain></SENT>
<SENT sid="223" pm="."><plain>This means that the best-mappers are not suitable for applications requiring full or nearly full sensitivity. </plain></SENT>
<SENT sid="224" pm="."><plain>It is mainly because the best-mappers are designed specifically for identifying the best mapping locations of each read.Table 1Rabema benchmark results (normalized found interval) for 100 k simulated readsMapperTimeBenchmark category[min:sec]All[%]All-best[%]Any-best[%]Bowtie2 a 0:1890.1897.6896.6092.2595.8796.4696.1494.4899.26100.0099.4997.5178.9552.7121.1393.6992.7692.2796.6396.2795.38BWA b 0:4992.28100.0099.8196.7598.84100.0099.8099.4098.89100.0099.8699.5079.4744.9116.6593.6178.4270.6793.7078.6171.17GEM c 0:1492.7598.2597.6595.6998.1598.2798.2197.9799.3699.4299.4299.2488.4467.0633.4498.1196.8795.8799.4298.7497.33Bowtie 2—99.73100.00100.00100.0099.97100.00100.00100.0099.97100.00100.00100.0099.9699.5395.4599.9599.6797.8999.9599.6797.89BWA40:3297.80100.0099.9799.6298.95100.0099.9799.6298.95100.0099.9799.6294.2683.5375.3093.8279.0370.9393.8279.1671.17GEM3:1596.0298.2598.2498.0998.1598.2798.1898.0199.3599.4299.4199.2495.9287.0266.3598.1797.0295.9499.4498.6897.17Masai17:4399.86100.00100.00100.0099.96100.00100.00100.0099.97100.00100.00100.0099.8799.5497.8799.8599.2998.5999.8598.3498.70Hobbes 27:5199.8299.9899.9799.9799.9799.9899.9799.9799.99100.0099.9999.9899.9899.8797.2099.9799.9899.8099.97100.0099.92mrFAST12:3299.32100.00100.00100.0099.42100.00100.00100.0099.43100.00100.00100.00100.0099.9687.51100.00100.0053.69100.00100.0054.09RazerS 3 d 41:3399.92100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.00100.0099.8498.62100.0099.9599.92100.0099.9599.92RazerS 354:59100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00Yara3:06—————————————————————BitMapper2:5799.99100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.0099.9999.98100.00100.00100.00100.00100.00100.00Bowtie2 a, BWA b, and GEM c represent the results in default sensitivity mode, while Bowtie2, BWA, and GEM represent the results in high sensitivity mode. </plain></SENT>
<SENT sid="225" pm="."><plain>The RazerS 3 d and RazerS 3 represent the results of RazerS 3 in default and full sensitivity mode, respectively. </plain></SENT>
<SENT sid="226" pm="."><plain>Note that in default mode, RazerS 3 is designed to find 99% of mapping locations, while Bowtie2, BWA, and GEM are designed to find the best mapping locations for each reads </plain></SENT>
</text></p><p><text><SENT sid="227" pm="."><plain>Compared to the best-mappers, all-mappers usually achieve higher sensitivity. </plain></SENT>
<SENT sid="228" pm="."><plain>For mrFAST, it is interesting that its Rabema any-best and all-best scores were 53.69 % and 54.09 % at edit distance 5, which were much lower than other all-mappers. </plain></SENT>
<SENT sid="229" pm="."><plain>Masai and Hobbes 2 lost a few mapping locations due to their heuristic methods. </plain></SENT>
<SENT sid="230" pm="."><plain>BitMapper and RazerS 3 were the only two mappers identifying 100 % all of the best and any of the best mapping locations. </plain></SENT>
<SENT sid="231" pm="."><plain>Note that the all, all-best and any-best scores of RazerS 3 in full sensitivity mode were 100 %, since we used the output of RazerS 3 in full sensitivity mode as the baseline for Rabema benchmark. </plain></SENT>
<SENT sid="232" pm="."><plain>However, it was extremely slow. </plain></SENT>
<SENT sid="233" pm="."><plain>The Rabema all-score for BitMapper was nearly 100 %, which was the best except RazerS 3 in full sensitivity. </plain></SENT>
<SENT sid="234" pm="."><plain>We did not present the sensitivity of Yara in Table 1, since it could not generate CIGAR strings for suboptimal alignments, which led to incorrect output of Rabema benchmark. </plain></SENT>
</text></p></sec><sec id="Sec15"><title><text><SENT sid="235" pm="."><plain>Rabema benchmark results on real data </plain></SENT>
</text></title><p><text><SENT sid="236" pm="."><plain>According to the results above, we found that the sensitivities of GEM and BWA on both high and default sensitivity modes were not high enough for the applications needing all or nearly all mapping locations. </plain></SENT>
<SENT sid="237" pm="."><plain>For Bowtie 2, although the sensitivity on high sensitivity mode has been improved, it spent much more time and memory than all-mappers. </plain></SENT>
<SENT sid="238" pm="."><plain>Thus, we would not present the results of them in the following. </plain></SENT>
</text></p><p><text><SENT sid="239" pm="."><plain>To compare the sensitivity of all-mappers on real data sets, we also measured the Rabema scores using 1 million 100 bp reads of human, as shown in Table 2. </plain></SENT>
<SENT sid="240" pm="."><plain>And to evaluate the sensitivity for different genomes, the Rabema scores for caenorhabditis elegans genome and arabidopsis thaliana genome were presented in Tables 3 and 4, respectively. </plain></SENT>
<SENT sid="241" pm="."><plain>According to these results, we fonud that the sensitivity of Bitmapper was also best among all of the all-mappers except RazerS 3 in full sensitivity, which generated the baseline of Rabema benchmark. </plain></SENT>
<SENT sid="242" pm="."><plain>As the results in Table 1, the Rabema scores of Yara were not included in Tables 2, 3 and 4 due to the absence of CIGAR strings.Table 2Rabema benchmark results (normalized found interval) for 1 million 100 bp real reads of humanMapperTimeBenchmark category[min:sec]All[%]All-best[%]Any-best[%]Masai42:5099.94100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.00100.0099.9798.93100.0099.9999.70100.0099.9999.80Hobbes 260:0599.8999.9999.9799.9799.9899.9899.9899.9999.9999.9999.99100.0099.9699.9198.4399.9999.9999.91100.00100.0099.99mrFAST98:0699.79100.00100.00100.0099.91100.00100.00100.0099.92100.00100.00100.00100.0099.9796.45100.0099.9693.61100.0099.9793.88RazerS 3 a 372:2199.90100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.00100.0099.8098.45100.0099.9099.47100.0099.9199.70RazerS 3512:46100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00Yara29:25—————————————————————BitMapper17:0399.99100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.00100.0099.9999.98100.00100.0099.98100.00100.0099.99RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) Table 3Rabema benchmark results (normalized found interval) for 1 million 100 bp real reads of caenorhabditis elegansMapperTimeBenchmark category[min:sec]All[%]All-best[%]Any-best[%]Masai3:0299.93100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.0099.9299.6798.1499.9899.9399.7899.9999.9599.89Hobbes 22:0199.94100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.0099.9999.8698.1899.9999.9699.7299.9999.9999.97mrFAST3:4098.89100.00100.00100.0099.95100.00100.00100.0099.96100.00100.00100.0099.9999.9996.5099.99100.0093.4399.99100.0093.89RazerS 3 a 7:1899.95100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.0099.9999.7998.6499.9999.8999.6199.9999.9599.84RazerS 37:53100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00Yara1:25—————————————————————BitMapper0:3299.99100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.00100.0099.9999.98100.0099.9999.98100.0099.9999.98RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) Table 4Rabema benchmark results (normalized found interval) for 1 million 101 bp real reads of arabidopsis thalianaMapperTimeBenchmark category[min:sec]All[%]All-best[%]Any-best[%]Masai3:0599.96100.00100.00100.0099.99100.00100.00100.0099.99100.00100.00100.0099.9799.9699.2599.9899.9699.2799.9899.9699.53Hobbes 21:5299.92100.00100.0099.9999.99100.00100.0099.9999.99100.00100.0099.9999.9799.8898.7299.9899.9999.6499.99100.0099.98mrFAST2:3099.88100.00100.00100.0099.98100.00100.00100.0099.99100.00100.00100.0099.9999.9997.9499.99100.0097.70100.00100.0098.50RazerS 3 a 8:3099.88100.00100.00100.0099.98100.00100.00100.0099.99100.00100.00100.0099.9999.7098.1299.9899.7098.6399.9999.8499.27RazerS 39:06100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00100.00Yara1:25—————————————————————BitMapper0:3299.99100.00100.0099.9999.99100.00100.0099.9999.99100.00100.0099.9999.98100.0099.9999.99100.0099.9999.99100.0099.99RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) </plain></SENT>
</text></p></sec></sec><sec id="Sec16"><title><text><SENT sid="243" pm="."><plain>Performance comparison on large data sets </plain></SENT>
</text></title><p><text><SENT sid="244" pm="."><plain>In order to compare the performance of BitMapper with other mappers on large data sets, we selected a single-end data set consisting of 10 million 100 bp reads from specimen HG00096 of the 1000 Genome project. </plain></SENT>
<SENT sid="245" pm="."><plain>And to compare the performance in different genomes, we used the first 10 million 100 bp reads of the data sets SRX026594 and the first 10 million 101 bp reads of SRR1604937, which were obtained from the DNA Data Bank of Japan (DDBJ) repository and National Center for Biotechnology Information (NCBI) repository, respectively. </plain></SENT>
<SENT sid="246" pm="."><plain>The first 10 million read pairs of these data sets were also used to measure the performance of paired-end alignment. </plain></SENT>
<SENT sid="247" pm="."><plain>Moreover, to demonstrate that Bitmapper also works well for longer reads, a real data set and two simulated data sets were used. </plain></SENT>
<SENT sid="248" pm="."><plain>The real data set consists of the first 10 million 151 bp reads of human in the HiSeq 2500 NA12878 demo data set in [23], while the two simulated data sets include 10 million 300 bp reads of caenorhabditis elegans and arabidopsis thaliana, respectively. </plain></SENT>
<SENT sid="249" pm="."><plain>All of these data sets with 100 bp, 151 bp and 300 bp reads were mapped to their reference genomes using edit distance threshold 5, 7 and 15, respectively. </plain></SENT>
</text></p><p><text><SENT sid="250" pm="."><plain>Because the Rabema benchmark cannot be implemented in such large data sets, we used the percentage of mapped reads and the number of mapping sites to measure the sensitivity, instead of Rabema scores. </plain></SENT>
<SENT sid="251" pm="."><plain>For running time comparison, the results of different mappers with single and eight threads were presented in Tables 5, 6, 7 and 8. </plain></SENT>
<SENT sid="252" pm="."><plain>Note that since Masai and mrFAST do not support multi-threading, the results of them with eight threads were omitted. </plain></SENT>
<SENT sid="253" pm="."><plain>In addition, peak memory consumption was also compared.Table 5Results for mapping 10 million 100 bp and 151 bp single-end reads against human genome100 bp reads151 bp readsMapperTime[min:sec]PeakMappingMappedTime [min:sec]PeakMappingMapped1 thr8 thrmemorysites[million]reads[%]1 thr8 thrmemorysites[million]reads[%]Masai361:35—20.1GB1371.1892.2736602:06—21.3GB939.8993.8483Hobbes 2587:04135:1014.0GB1368.8692.2767694:53151:5214.5GB936.4293.8481mrFAST921:46—4.9GB1374.7692.2572795:59—6.5GB939.4893.7376RazerS 3 a ——&gt;24GB————&gt;24GB——RazerS 3——&gt;24GB————&gt;24GB——Yara278:0978:109.0GB1367.4292.2658389:5693:159.3GB939.4493.8480BitMapper158:5732:5917.9GB1375.6892.2771135:0627:5619.2GB940.1693.8487RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) Table 6Results for mapping 10 million 100 bp single-end reads against caenorhabditis elegans and arabidopsis thalianaCaenorhabditis elegansArabidopsis thalianaMapperTime [min:sec]PeakMappingMappedTime [min:sec]PeakMappingMapped1 thr8 thrmemorysites[million]reads[%]1 thr8 thrmemorysites[million]reads[%]Masai22:28—3.2GB54.6190.414021:06—3.3GB57.8398.2578Hobbes 216:514:420.9GB55.4090.415016:053:421.0GB57.7698.2616mrFAST35:15—4.2GB55.6090.411923:12—4.3GB57.9498.2609RazerS 3 a 69:2459:3912.0GB55.2490.411886:3972:3110.3GB57.4998.2551RazerS 375:2761:4012.6GB55.6190.415489:3175:2610.4GB57.9698.2622Yara13:423:371.1GB54.6590.415015:134:011.2GB57.8798.2608BitMapper5:081:254.5GB55.6390.41595:241:304.5GB57.9498.2631RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) Table 7Results for mapping 10 million 300bp single-end reads against caenorhabditis elegans and arabidopsis thalianaCaenorhabditis elegansArabidopsis thalianaMapperTime [min:sec]PeakMappingMappedTime [min:sec]PeakMappingMapped1 thr8 thrmemorysites[million]reads[%]1 thr8 thrmemorysites[million]reads[%]Masai48:54—11.5GB17.4499.989446:26—11.8GB14.8399.9884Hobbes 266:3813:120.9GB2.140.532764:2512:501.0GB0.010.0219mrFAST80:56—9.9GB16.7196.188847:00—10.0GB14.2796.2356RazerS 3 a 195:07182:3411.9GB17.4399.9894172:21155:4812.0GB14.8299.9884RazerS 3209:30185:2912.6GB17.4499.9894185:05160:0212.0GB14.8399.9884Yara34:207:432.1GB17.3399.989429:446:342.1GB14.7299.9884BitMapper12:264:5710.1GB17.4399.989412:104:5510.2GB14.8399.9884RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) Table 8Results for mapping 10 million paired-end readsHumanCaenorhabditis elegansArabidopsis thalianaMapperTime [min:sec]PeakMappedTime [min:sec]PeakMappedTime [min:sec]PeakMapped1 thr8 thrmemorypairs[%]1 thr8 thrmemorypairs[%]1 thr8 thrmemorypairs[%]Masai464:07—16.8GB84.898431:07—11.3GB65.867429:40—11.6GB64.9149Hobbes 2439:05105:2914.6GB87.394580:0422:410.9GB67.173923:596:211.0GB68.1224RazerS 3 a ——&gt;24GB—61:1547:1116.4GB67.184151:2541:3114.9GB68.1250RazerS 3——&gt;24GB—66:2850:1317.4GB67.189455:3342:3817.1GB68.1473Yara489:58117:4013.2GB87.161423:435:472.0GB67.105828:096:522.2GB66.8150BitMapper177:4739:3921.5GB87.423311:163:158.0GB67.18836:472:208.1GB68.1500RazerS 3 a: the result of RazerS 3 in default sensitivity mode (i.e., finding 99% of mapping locations); RazerS 3: the result of RazerS 3 in full sensitivity mode (i.e., finding 100% of mapping locations) </plain></SENT>
</text></p><sec id="Sec17"><title><text><SENT sid="254" pm="."><plain>Sensitivity and running time comparison </plain></SENT>
</text></title><p><text><SENT sid="255" pm="."><plain>Table 5 shows the results of mapping 10 million 100 bp and 151 bp single-end reads to the whole human genome. </plain></SENT>
<SENT sid="256" pm="."><plain>Results of the best-mappers including GEM, Bowtie 2 and BWA were left out, because the sensitivity of them is usually substantially less than that of all-mappers and the running time is usually longer, as shown in Table 1 and Additional file 1: Table S3. </plain></SENT>
<SENT sid="257" pm="."><plain>The results in Table 5 show that BitMapper was the best in terms of sensitivity and running time on the human genome data sets. </plain></SENT>
<SENT sid="258" pm="."><plain>For 10 million 151 bp reads, it was nearly 3 times faster than the second fastest read mapper Yara, and achieved highest sensitivity with 940.16 million mapping locations identified and 93.8487 % reads mapped in the human genome. </plain></SENT>
<SENT sid="259" pm="."><plain>Compared to Masai, BitMapper was more than 4 times faster and found more mapping locations. </plain></SENT>
<SENT sid="260" pm="."><plain>For 10 million 100 bp reads, Bitmapper also presented the best performance among all read mappers. </plain></SENT>
<SENT sid="261" pm="."><plain>The results of RazerS 3 were not shown, since the memory requirement of RazerS 3 was larger than the memory capacity of our computer. </plain></SENT>
<SENT sid="262" pm="."><plain>Similarly, BitMapper was superior in mapping 10 million single-end reads against the genomes of caenorhabditis elegans and arabidopsis thaliana, as shown in Table 6. </plain></SENT>
<SENT sid="263" pm="."><plain>And for longer 300 bp reads, Bitmapper was still more efficient than others, as shown in Table 7. </plain></SENT>
</text></p><p><text><SENT sid="264" pm="."><plain>Finally, Table 8 shows the experimental results for paired-end alignment, where three data sets consisting of 10 million read pairs from different genomes were used to evaluate the performance. </plain></SENT>
<SENT sid="265" pm="."><plain>Again, BitMapper was the best, 2.5 times faster than Hobbes 2, nearly 3 times faster than Masai and Yara in human genome. </plain></SENT>
<SENT sid="266" pm="."><plain>Note that the results of the human genome using RazerS 3 are not shown here, because the memory requirement of RazerS 3 was larger than the memory capacity of our computer. </plain></SENT>
<SENT sid="267" pm="."><plain>For caenorhabditis elegans and arabidopsis thaliana, BitMapper was also several times faster than the existing all-mappers. </plain></SENT>
<SENT sid="268" pm="."><plain>In addition, BitMapper still showed great performance in sensitivity comparison. </plain></SENT>
<SENT sid="269" pm="."><plain>We did not present the results of mrFAST, since it reported many extra locations. </plain></SENT>
<SENT sid="270" pm="."><plain>Thus, the running time was extremely long. </plain></SENT>
</text></p></sec><sec id="Sec18"><title><text><SENT sid="271" pm="."><plain>Memory usage comparison </plain></SENT>
</text></title><p><text><SENT sid="272" pm="."><plain>If a reference genome is large, the memory usage of most mappers mainly depends on the size of the genome and the index for it. </plain></SENT>
<SENT sid="273" pm="."><plain>For instance, the human genome could be regarded as a long string including 3.15 billion symbols so that 3GB is required to store them. </plain></SENT>
<SENT sid="274" pm="."><plain>For hash table index, the locations for each q-gram should be saved and a location is represented by a 32-bit integer. </plain></SENT>
<SENT sid="275" pm="."><plain>Thus, BitMapper and Hobbes 2, which both index the reference genome using hash tables, require more than 14GB to load the index and genome. </plain></SENT>
<SENT sid="276" pm="."><plain>Similarly, Masai requires large memory space and uses about 20GB to map 10 million reads to human genome. </plain></SENT>
<SENT sid="277" pm="."><plain>Although the hash table index is also used in mrFAST, only 7GB is used since it splits the whole human genome and index into several segments and loads one of them at a time. </plain></SENT>
<SENT sid="278" pm="."><plain>Yara is another read mapper which requires small memory space, since it uses the BWT and FM-index. </plain></SENT>
<SENT sid="279" pm="."><plain>The memory usage of RazerS 3 mainly depends on the number of mapping locations. </plain></SENT>
<SENT sid="280" pm="."><plain>It needs more than 24GB to map 10 million 151 bp reads of human. </plain></SENT>
</text></p></sec></sec></sec></SecTag><SecTag type="CONCL"><sec id="Sec19" sec-type="conclusion"><title><text><SENT sid="281" pm="."><plain>Conclusion </plain></SENT>
</text></title><p><text><SENT sid="282" pm="."><plain>BitMapper is designed to find all mapping locations for each read based on bit-vector computing. </plain></SENT>
<SENT sid="283" pm="."><plain>In experiments on both simulated and real data sets, it achieved nearly full sensitivity and superior speed, outperforming existing state-of-the-art all-mappers. </plain></SENT>
</text></p><p><text><SENT sid="284" pm="."><plain>The verification of edit distance constitutes a significant portion of the whole running time. </plain></SENT>
<SENT sid="285" pm="."><plain>We propose a new vectorized Gene Myers’ bit-vector algorithm, which calculates the edit distance of a read to multiple locations in a given genome. </plain></SENT>
<SENT sid="286" pm="."><plain>To make full use of the algorithm, the traditional verification scheme is redesigned in BitMapper. </plain></SENT>
</text></p><p><text><SENT sid="287" pm="."><plain>Recently, a new SIMD instruction set AVX2 has been applied to many CPUs. </plain></SENT>
<SENT sid="288" pm="."><plain>Thus, the performance of our vectorized Gene Myers’ bit-vector algorithm will be improved further by using AVX2 in the future. </plain></SENT>
<SENT sid="289" pm="."><plain>The vectorized bit-vector computing approach can also be used to accelerate filtration, which is a future research direction in BitMapper. </plain></SENT>
</text></p><p><text><SENT sid="290" pm="."><plain>BitMapper is implemented in C under a GPL license and is able to download at <ext-link ext-link-type="uri" xlink:href="http://home.ustc.edu.cn/%7Echhy">http://home.ustc.edu.cn/%7Echhy</ext-link>. </plain></SENT>
</text></p></sec></SecTag><sec sec-type="supplementary-material"><title><text><SENT sid="291" pm="."><plain>Additional file </plain></SENT>
</text></title><sec id="Sec20"><p><text><SENT sid="292" pm="."><plain>Additional file 1 Supplementary material. This file consists of the configuration of each read mapper and the analysis of the two vectorized verification schemes. </plain></SENT>
<SENT sid="293" pm="."><plain>Besides, we present the pseudo code of our vectorized bit-vector algorithm and the performance comparison between it and other existing implementation of the Gene Myers’ algorithmin in the additional file. </plain></SENT>
</text></p></sec></sec></body><back><fn-group><fn><p><text><SENT sid="294" pm="."><plain>Competing interests </plain></SENT>
</text></p><p><text><SENT sid="295" pm="."><plain>The authors declare that they have no competing interests. </plain></SENT>
</text></p></fn><fn><p><text><SENT sid="296" pm="."><plain>Authors’ contributions </plain></SENT>
</text></p><p><text><SENT sid="297" pm="."><plain>HC developed the vectorized Gene Myers’ bit-vector algorithm, and implemented the whole software. </plain></SENT>
<SENT sid="298" pm="."><plain>HC, JY and YX designed the strategies in the software. </plain></SENT>
<SENT sid="299" pm="."><plain>HC,YX and YS drafted the manuscript. </plain></SENT>
<SENT sid="300" pm="."><plain>HJ tested the software and revised the bugs of it. </plain></SENT>
<SENT sid="301" pm="."><plain>All authors read and approved the final manuscript. </plain></SENT>
</text></p></fn></fn-group><SecTag type="ACK_FUND"><ack><title>Acknowledgements</title><p><text4fund><text><SENT sid="302" pm="."><plain>The authors would like to thank Yanan Zhao for her suggestions about our article. </plain></SENT>
<SENT sid="303" pm="."><plain>This work was partially supported by the Key Project of The National Nature Science Foundation of China under the grant No. 60533020 and the Fund for Foreign Scholars in University Research and Teaching Programs(B07033). </plain></SENT>
</text></text4fund></p></ack></SecTag><SecTag type="REF"><ref-list id="Bib1"><title>References</title><ref id="CR1"><text><SENT sid="304" pm="."><plain>1Langmead B, Trapnell C, Pop M, Salzberg SL. </plain></SENT>
<SENT sid="305" pm="."><plain>Ultrafast and memory-efficient alignment of short dna sequences to the human genome. </plain></SENT>
<SENT sid="306" pm="."><plain>Genome Biol. </plain></SENT>
<SENT sid="307" pm="."><plain>2009; 10(3):25. </plain></SENT>
</text></ref><ref id="CR2"><text><SENT sid="308" pm="."><plain>2LangmeadBSalzbergSLFast gapped-read alignment with bowtie 2Nat Methods201294357910.1038/nmeth.192322388286 </plain></SENT>
</text></ref><ref id="CR3"><text><SENT sid="309" pm="."><plain>3LiHDurbinRFast and accurate short read alignment with burrows–wheeler transformBioinformatics2009251417546010.1093/bioinformatics/btp32419451168 </plain></SENT>
</text></ref><ref id="CR4"><text><SENT sid="310" pm="."><plain>4Marco-SolaSSammethMGuigóRRibecaPThe gem mapper: fast, accurate and versatile alignment by filtrationNat Methods20129121185810.1038/nmeth.222123103880 </plain></SENT>
</text></ref><ref id="CR5"><text><SENT sid="311" pm="."><plain>5WeeseDHoltgreweMReinertKRazers 3: faster, fully sensitive read mappingBioinformatics20122820259259910.1093/bioinformatics/bts50522923295 </plain></SENT>
</text></ref><ref id="CR6"><text><SENT sid="312" pm="."><plain>6Kim J, Li C, Xie X. </plain></SENT>
<SENT sid="313" pm="."><plain>Improving read mapping using additional prefix grams. </plain></SENT>
<SENT sid="314" pm="."><plain>BMC Bioinformatics. </plain></SENT>
<SENT sid="315" pm="."><plain>2014; 15(1):42. </plain></SENT>
</text></ref><ref id="CR7"><text><SENT sid="316" pm="."><plain>7HachFHormozdiariFAlkanCHormozdiariFBirolIEichlerEEmrsfast: a cache-oblivious algorithm for short-read mappingNat Methods201078576710.1038/nmeth0810-57620676076 </plain></SENT>
</text></ref><ref id="CR8"><text><SENT sid="317" pm="."><plain>8Xin H, Lee D, Hormozdiari F, Yedkar S, Mutlu O, Alkan C. </plain></SENT>
<SENT sid="318" pm="."><plain>Accelerating read mapping with fasthash. </plain></SENT>
<SENT sid="319" pm="."><plain>BMC Genomics. </plain></SENT>
<SENT sid="320" pm="."><plain>2013; 14(Suppl 1):13. </plain></SENT>
</text></ref><ref id="CR9"><text><SENT sid="321" pm="."><plain>9AhmadiABehmAHonnalliNLiCWengLXieXHobbes: optimized gram-based methods for efficient read alignmentNucleic Acids Res20124041110.1093/nar/gkr1246 </plain></SENT>
</text></ref><ref id="CR10"><text><SENT sid="322" pm="."><plain>10SiragusaEWeeseDReinertKFast and accurate read mapping with approximate seeds and multiple backtrackingNucleic Acids Res201341778810.1093/nar/gkt005 </plain></SENT>
</text></ref><ref id="CR11"><text><SENT sid="323" pm="."><plain>11MyersGA fast bit-vector algorithm for approximate string matching based on dynamic programmingJ ACM (JACM)199946339541510.1145/316542.316550 </plain></SENT>
</text></ref><ref id="CR12"><text><SENT sid="324" pm="."><plain>12HyyröHA bit-vector algorithm for computing levenshtein and damerau edit distancesNord J Comput20031012939 </plain></SENT>
</text></ref><ref id="CR13"><text><SENT sid="325" pm="."><plain>13Siragusa WD E, Reinert K. </plain></SENT>
<SENT sid="326" pm="."><plain>Yara: well-defined alignment of high-throughput sequencing reads. http://www.seqan.de/projects/yara/. </plain></SENT>
</text></ref><ref id="CR14"><text><SENT sid="327" pm="."><plain>14RasmussenKRStoyeJMyersEWEfficient q-gram filters for finding all ε-matches over a given lengthJ Comput Biol200613229630810.1089/cmb.2006.13.29616597241 </plain></SENT>
</text></ref><ref id="CR15"><text><SENT sid="328" pm="."><plain>15WeeseDEmdeAKRauschTDöringAReinertKRazers-fast read mapping with sensitivity controlGenome Res200919916465410.1101/gr.088823.10819592482 </plain></SENT>
</text></ref><ref id="CR16"><text><SENT sid="329" pm="."><plain>16SellersPHThe theory and computation of evolutionary distances: pattern recognitionJ Algorithms1980143597310.1016/0196-6774(80)90016-4 </plain></SENT>
</text></ref><ref id="CR17"><text><SENT sid="330" pm="."><plain>17UkkonenEFinding approximate patterns in stringsJ Algorithms198561132710.1016/0196-6774(85)90023-9 </plain></SENT>
</text></ref><ref id="CR18"><text><SENT sid="331" pm="."><plain>18Holtgrewe M. </plain></SENT>
<SENT sid="332" pm="."><plain>Mason–a read simulator for second generation sequencing data. </plain></SENT>
<SENT sid="333" pm="."><plain>Technical Report FU Berlin. </plain></SENT>
<SENT sid="334" pm="."><plain>2010. </plain></SENT>
</text></ref><ref id="CR19"><text><SENT sid="335" pm="."><plain>191000 Genomes: a Deep Catalog of Human Genetic Variation. http://www.1000genomes.org/data. </plain></SENT>
</text></ref><ref id="CR20"><text><SENT sid="336" pm="."><plain>20DNA Data Bank of Japan. <ext-link ext-link-type="uri" xlink:href="ftp://ftp.ddbj.nig.ac.jp">ftp://ftp.ddbj.nig.ac.jp</ext-link>. </plain></SENT>
</text></ref><ref id="CR21"><text><SENT sid="337" pm="."><plain>21National Center for Biotechnology Information. http://www.ncbi.nlm.nih.gov/. </plain></SENT>
</text></ref><ref id="CR22"><text><SENT sid="338" pm="."><plain>22Holtgrewe M, Emde AK, Weese D, Reinert K. </plain></SENT>
<SENT sid="339" pm="."><plain>A novel and well-defined benchmarking method for second generation read mapping. </plain></SENT>
<SENT sid="340" pm="."><plain>BMC Bioinformatics. </plain></SENT>
<SENT sid="341" pm="."><plain>2011; 12(1):210. </plain></SENT>
</text></ref><ref id="CR23"><text><SENT sid="342" pm="."><plain>23BaseSpace Sequencing Data Sets. http://www.illumina.com/informatics/research/sequencing-data-analysis-management/sequencing-data-library.html. </plain></SENT>
</text></ref></ref-list></SecTag></back></article>
